{% extends "base.html" %}
{% block content %}
<section class="card">
  <h2>Job #{{ job.id }} â€” {{ job.original_filename }}</h2>
  <p>Status: <span class="badge {{ job.status.value }}"><span class="badge-dot"></span>{{ job.status.value.replace("_", " ") }}</span></p>
  <p>MD5: <span class="mono">{{ job.md5 }}</span></p>
  <p>Message: {{ job.message or "-" }}</p>
  <div class="actions">
    {% if job.status.value == "error" %}
      <button id="retry-job">Retry</button>
      <button id="delete-job" class="danger">Remove</button>
    {% endif %}
  </div>
  <p id="job-action-status" class="muted"></p>
</section>

<section class="card">
  <h3>Components & Candidates</h3>
{% if job.components %}
  {% set symbols = namespace(options=[]) %}
  {% set footprints = namespace(options=[]) %}
  {% set models = namespace(options=[]) %}
  {% set selected_symbol = namespace(id=None, comp=None) %}
  {% set selected_footprint = namespace(id=None, comp=None) %}
  {% set selected_model = namespace(id=None, comp=None) %}
  {% for comp in job.components %}
    {% if comp.selected_symbol_id and not selected_symbol.id %}
      {% set selected_symbol.id = comp.selected_symbol_id %}
      {% set selected_symbol.comp = comp.id %}
    {% endif %}
    {% if comp.selected_footprint_id and not selected_footprint.id %}
      {% set selected_footprint.id = comp.selected_footprint_id %}
      {% set selected_footprint.comp = comp.id %}
    {% endif %}
    {% if comp.selected_model_id and not selected_model.id %}
      {% set selected_model.id = comp.selected_model_id %}
      {% set selected_model.comp = comp.id %}
    {% endif %}
    {% for cand in comp.candidates | sort(attribute='combined_score', reverse=True) %}
      {% if cand.type.value == 'symbol' %}
        {% set _ = symbols.options.append({"id": cand.id, "name": cand.name, "comp_id": comp.id, "comp_name": comp.name, "score": cand.combined_score, "pins": cand.pin_count, "path": cand.rel_path, "file": cand.rel_path.name if cand.rel_path else cand.name}) %}
      {% elif cand.type.value == 'footprint' %}
        {% set _ = footprints.options.append({"id": cand.id, "name": cand.name, "comp_id": comp.id, "comp_name": comp.name, "score": cand.combined_score, "pads": cand.pad_count, "path": cand.rel_path, "file": cand.rel_path.name if cand.rel_path else cand.name}) %}
      {% elif cand.type.value == 'model' %}
        {% set _ = models.options.append({"id": cand.id, "name": cand.name, "comp_id": comp.id, "comp_name": comp.name, "score": cand.combined_score, "desc": cand.description, "path": cand.rel_path, "file": cand.rel_path.name if cand.rel_path else cand.name}) %}
      {% endif %}
    {% endfor %}
  {% endfor %}
  <form id="selection-form">
    <div id="selection-hidden-inputs" hidden>
      {% for comp in job.components %}
        <input type="hidden" name="symbol_{{ comp.id }}" value="{{ comp.selected_symbol_id or '' }}">
        <input type="hidden" name="footprint_{{ comp.id }}" value="{{ comp.selected_footprint_id or '' }}">
        <input type="hidden" name="model_{{ comp.id }}" value="{{ comp.selected_model_id or '' }}">
      {% endfor %}
    </div>
    <div class="muted small">Pick one choice per type. Choosing an option fills that component and clears the rest for that type. Scroll inside each card to see all options.</div>
    <div class="grid three-col align-start candidate-columns">
      <div class="candidate-card">
        <div class="card-header small">
          <h4>Symbols</h4>
          <span class="count-pill">{{ symbols.options|length }} option{{ '' if symbols.options|length == 1 else 's' }}</span>
        </div>
        <div class="option-stack" data-type="symbol">
          {% if symbols.options %}
            {% for opt in symbols.options | sort(attribute='score', reverse=True) %}
              <button type="button" class="option-tile {% if opt.id == selected_symbol.id %}selected{% endif %}" data-type="symbol" data-cand-id="{{ opt.id }}" data-comp-id="{{ opt.comp_id }}" data-path="{{ opt.path }}" data-file="{{ opt.file }}" data-name="{{ opt.name }}">
                <div class="option-head">
                  <div class="option-name">{{ opt.name }}</div>
                  {% if opt.comp_name != opt.name %}<div class="option-tag">{{ opt.comp_name }}</div>{% endif %}
                </div>
                <div class="option-meta-row">
                  <span class="meta-chip">Score {{ "%.2f"|format(opt.score or 0) }}</span>
                  <span class="meta-chip">Pins {{ opt.pins or "-" }}</span>
                </div>
                {% if opt.file %}<div class="option-file mono small">{{ opt.file }}</div>{% endif %}
                {% if opt.path %}<div class="option-path mono small">{{ opt.path }}</div>{% endif %}
              </button>
            {% endfor %}
          {% else %}
            <p class="muted">No symbol candidates.</p>
          {% endif %}
          <button type="button" class="option-tile none" data-type="symbol" data-cand-id="">
            None
          </button>
        </div>
        <div class="viewer-panel" id="viewer-symbol">Select a symbol to see its preview.</div>
      </div>

      <div class="candidate-card">
        <div class="card-header small">
          <h4>Footprints</h4>
          <span class="count-pill">{{ footprints.options|length }} option{{ '' if footprints.options|length == 1 else 's' }}</span>
        </div>
        <div class="option-stack" data-type="footprint">
          {% if footprints.options %}
            {% for opt in footprints.options | sort(attribute='score', reverse=True) %}
              <button type="button" class="option-tile {% if opt.id == selected_footprint.id %}selected{% endif %}" data-type="footprint" data-cand-id="{{ opt.id }}" data-comp-id="{{ opt.comp_id }}" data-path="{{ opt.path }}" data-file="{{ opt.file }}" data-name="{{ opt.name }}">
                <div class="option-head">
                  <div class="option-name">{{ opt.name }}</div>
                  {% if opt.comp_name != opt.name %}<div class="option-tag">{{ opt.comp_name }}</div>{% endif %}
                </div>
                <div class="option-meta-row">
                  <span class="meta-chip">Score {{ "%.2f"|format(opt.score or 0) }}</span>
                  <span class="meta-chip">Pads {{ opt.pads or "-" }}</span>
                </div>
                {% if opt.file %}<div class="option-file mono small">{{ opt.file }}</div>{% endif %}
                {% if opt.path %}<div class="option-path mono small">{{ opt.path }}</div>{% endif %}
              </button>
            {% endfor %}
          {% else %}
            <p class="muted">No footprint candidates.</p>
          {% endif %}
          <button type="button" class="option-tile none" data-type="footprint" data-cand-id="">
            None
          </button>
        </div>
        <div class="viewer-panel" id="viewer-footprint">Select a footprint to see its preview.</div>
      </div>

      <div class="candidate-card">
        <div class="card-header small">
          <h4>3D Models</h4>
          <span class="count-pill">{{ models.options|length }} option{{ '' if models.options|length == 1 else 's' }}</span>
        </div>
        <div class="option-stack" data-type="model">
          {% if models.options %}
            {% for opt in models.options | sort(attribute='score', reverse=True) %}
              <button type="button" class="option-tile {% if opt.id == selected_model.id %}selected{% endif %}" data-type="model" data-cand-id="{{ opt.id }}" data-comp-id="{{ opt.comp_id }}" data-path="{{ opt.path }}" data-file="{{ opt.file }}" data-name="{{ opt.name }}">
                <div class="option-head">
                  <div class="option-name">{{ opt.name }}</div>
                  {% if opt.comp_name != opt.name %}<div class="option-tag">{{ opt.comp_name }}</div>{% endif %}
                </div>
                <div class="option-meta-row">
                  <span class="meta-chip">Score {{ "%.2f"|format(opt.score or 0) }}</span>
                  <span class="meta-chip">{{ opt.desc or "-" }}</span>
                </div>
                {% if opt.file %}<div class="option-file mono small">{{ opt.file }}</div>{% endif %}
                {% if opt.path %}<div class="option-path mono small">{{ opt.path }}</div>{% endif %}
              </button>
            {% endfor %}
          {% else %}
            <p class="muted">No 3D model candidates.</p>
          {% endif %}
          <button type="button" class="option-tile none" data-type="model" data-cand-id="">
            None
          </button>
        </div>
        <div class="viewer-panel" id="viewer-model">
          <div id="model-fallback"></div>
          <div class="muted" id="model-preview-note">Select a model to see its preview.</div>
          <div id="model-canvas"></div>
        </div>
      </div>
    </div>

    <div class="card dest-card">
      <h4>Destination folder</h4>
      <div class="dest-grid">
        <label>
          Subfolder name (applied to all roots)
          {% set folder_suggestions = (import_paths.symbol_subdirs or []) + (import_paths.footprint_subdirs or []) + (import_paths.model_subdirs or []) %}
          {% set uniq = folder_suggestions | unique %}
          <input type="text" id="common-subdir" list="common-folders" placeholder="Leave blank for root">
          <datalist id="common-folders">
            {% for d in uniq %}<option value="{{ d }}">{{ d }}</option>{% endfor %}
          </datalist>
        </label>
      </div>
      <p class="muted small">This folder name will be used under each root (symbols/footprints/3D), e.g. symbols/Buzzer, footprints/Buzzer, 3d/Buzzer.</p>
      <div class="actions" style="margin-top: 10px;">
        <button type="button" id="import-btn">Import</button>
      </div>
    </div>
  </form>
{% else %}
  <p>No components found.</p>
{% endif %}
</section>

<section class="card">
  <h4>Attach extra file to this job</h4>
  <p class="muted small">Add an extra STEP/zip/symbol/footprint file to this job (e.g., standalone STEP). It will be scanned and added as additional candidates.</p>
  <div class="attach-row">
    <input type="file" id="attach-file-input" />
    <button type="button" id="attach-file-btn">Add to job</button>
  </div>
  <p class="muted small" id="attach-status"></p>
</section>

<section class="card">
  <h3>Logs</h3>
  {% if job.logs %}
  <ul class="logs">
    {% for log in job.logs %}
    <li><span class="mono">{{ log.created_at.strftime("%Y-%m-%d %H:%M") }}</span> [{{ log.level }}] {{ log.message }}</li>
    {% endfor %}
  </ul>
  {% else %}
  <p>No logs yet.</p>
  {% endif %}
</section>

<script>
  const jobId = {{ job.id }};
  const actionStatus = document.getElementById('job-action-status');
  const retryBtn = document.getElementById('retry-job');
  const deleteBtn = document.getElementById('delete-job');
  function setActionStatus(msg) { if (actionStatus) actionStatus.textContent = msg; }

  retryBtn?.addEventListener('click', async () => {
    setActionStatus("Retrying...");
    try {
      const resp = await fetch(`/api/jobs/${jobId}/retry`, { method: "POST" });
      const body = await resp.json();
      if (!resp.ok) throw new Error(body.detail || resp.statusText);
      setActionStatus("Retry kicked off. Reloading...");
      window.location.reload();
    } catch (err) {
      setActionStatus(`Retry failed: ${err?.message || err}`);
    }
  });

  deleteBtn?.addEventListener('click', async () => {
    if (!confirm("Remove this job and its files?")) return;
    setActionStatus("Removing...");
    try {
      const resp = await fetch(`/api/jobs/${jobId}`, { method: "DELETE" });
      if (!resp.ok) {
        const body = await resp.json().catch(() => ({}));
        throw new Error(body.detail || resp.statusText);
      }
      window.location.href = "/";
    } catch (err) {
      setActionStatus(`Remove failed: ${err?.message || err}`);
    }
  });
  async function saveSelections() {
    const form = document.getElementById('selection-form');
    if (!form) return { ok: false, message: "No form present" };
    const data = {};
    const symbolMap = {};
    const footprintMap = {};
    const modelMap = {};
    document.querySelectorAll('input[name^="symbol_"]').forEach((hidden) => { symbolMap[hidden.name.replace("symbol_", "")] = hidden.value || null; });
    document.querySelectorAll('input[name^="footprint_"]').forEach((hidden) => { footprintMap[hidden.name.replace("footprint_", "")] = hidden.value || null; });
    document.querySelectorAll('input[name^="model_"]').forEach((hidden) => { modelMap[hidden.name.replace("model_", "")] = hidden.value || null; });
    {% for comp in job.components %}
    data["{{ comp.id }}"] = {
      symbol_id: symbolMap["{{ comp.id }}"] || null,
      footprint_id: footprintMap["{{ comp.id }}"] || null,
      model_id: modelMap["{{ comp.id }}"] || null,
    };
    {% endfor %}
    const resp = await fetch(`/api/jobs/${jobId}/select`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
    const body = await resp.json();
    return { ok: resp.ok, body, message: body.detail || "" };
  }

  function applyTypeSelection(type, candId, compId) {
    document.querySelectorAll(`input[name^="${type}_"]`).forEach((hidden) => { hidden.value = ""; });
    if (candId && compId) {
      const target = document.querySelector(`input[name="${type}_${compId}"]`);
      if (target) target.value = candId;
    }
  }

  function markSelected(type, activeBtn) {
    document.querySelectorAll(`.option-tile[data-type="${type}"]`).forEach((btn) => {
      btn.classList.toggle('selected', btn === activeBtn);
    });
  }

  const viewers = {
    symbol: document.getElementById('viewer-symbol'),
    footprint: document.getElementById('viewer-footprint'),
    model: document.getElementById('viewer-model'),
  };

  const previewCache = {};
  const commonDestInput = document.getElementById('common-subdir');
  let threeLoaded = null;
  let currentModelUrl = null;

  async function fetchPreview(type, btn) {
    const viewer = viewers[type];
    if (!viewer) return;
    const isModel = type === "model";
    const noteEl = isModel ? document.getElementById('model-preview-note') : null;
    const fallbackEl = isModel ? document.getElementById('model-fallback') : null;
    if (!btn) {
      if (isModel) {
        clearModelCanvas();
        if (fallbackEl) fallbackEl.innerHTML = "";
        if (noteEl) noteEl.textContent = "Select a model to see its preview.";
      } else {
        viewer.innerHTML = `<div class="muted">Select an option to see its preview.</div>`;
      }
      return;
    }
    const id = btn.dataset.candId;
    if (!id) {
      if (isModel) {
        clearModelCanvas();
        if (fallbackEl) fallbackEl.innerHTML = "";
        if (noteEl) noteEl.textContent = "Select a model to see its preview.";
      } else {
        viewer.innerHTML = `<div class="muted">Select an option to see its preview.</div>`;
      }
      return;
    }
    if (!isModel && previewCache[id]) {
      viewer.innerHTML = previewCache[id];
      return;
    }
    if (isModel) {
      if (noteEl) noteEl.textContent = "Loading preview...";
      if (fallbackEl) fallbackEl.innerHTML = "";
    } else {
      viewer.innerHTML = "Loading preview...";
    }
    try {
      const resp = await fetch(`/api/jobs/candidates/${id}/render`);
      const body = await resp.json();
      if (!resp.ok) throw new Error(body.detail || resp.statusText);
      const img = body.image_data
        ? `<img src="${body.image_data}" alt="preview" class="preview-image">`
        : "<div class='muted'>No preview available</div>";
      const noteRaw = body.note || "";
      const note = noteRaw ? `<div class="muted small">${noteRaw}</div>` : "";
      const showNote = noteRaw && /fail|error|missing|unsupported/i.test(noteRaw);
      const content = `${img}${showNote ? note : ""}`;
      if (type === "symbol" || type === "footprint") {
        const wrapped = `
          <div class="preview-window">
            <div class="preview-inner">
              ${img}
            </div>
          </div>
          ${showNote ? note : ""}
        `;
        previewCache[id] = wrapped;
        viewer.innerHTML = wrapped;
        return;
      }
      previewCache[id] = content;
      if (isModel) {
        if (noteEl) {
          if (showNote) {
            noteEl.textContent = "Server render unavailable; using browser preview.";
          } else {
            noteEl.textContent = "";
          }
        }
        if (fallbackEl) fallbackEl.innerHTML = "";
        // Keep model viewer structure intact; renderModel handles canvas painting.
      } else {
        viewer.innerHTML = content;
      }
    } catch (err) {
      if (isModel) {
        if (noteEl) noteEl.textContent = `Preview unavailable: ${err?.message || err}`;
      } else {
        viewer.innerHTML = `<div class="muted">Preview unavailable: ${err?.message || err}</div>`;
      }
      console.error("Preview fetch failed", { type, id, error: err });
    }
  }

  async function loadThree() {
    if (threeLoaded) return threeLoaded;
    const threeBase = 'https://unpkg.com/three@0.160.0';
    threeLoaded = Promise.all([
      import(`${threeBase}/build/three.module.js?module`),
      import(`${threeBase}/examples/jsm/controls/OrbitControls.js?module`),
      import(`${threeBase}/examples/jsm/loaders/OBJLoader.js?module`),
      import(`${threeBase}/examples/jsm/loaders/STLLoader.js?module`),
      import(`${threeBase}/examples/jsm/loaders/VRMLLoader.js?module`),
    ]).then(([THREE, { OrbitControls }, { OBJLoader }, { STLLoader }, { VRMLLoader }]) => ({ THREE, OrbitControls, OBJLoader, STLLoader, VRMLLoader }));
    return threeLoaded;
  }

  let occtLoaded = null;
  function loadOcctViaScript(url) {
    return new Promise((resolve, reject) => {
      if (window.occtimportjs) return resolve({ factory: window.occtimportjs, base: url.slice(0, url.lastIndexOf('/') + 1) });
      const script = document.createElement('script');
      script.src = url;
      script.onload = () => {
        if (window.occtimportjs && typeof window.occtimportjs === 'function') {
          resolve({ factory: window.occtimportjs, base: url.slice(0, url.lastIndexOf('/') + 1) });
        } else {
          reject(new Error('occtimportjs not found after script load'));
        }
      };
      script.onerror = () => reject(new Error(`Failed to load script ${url}`));
      document.head.appendChild(script);
    });
  }

  async function loadOcct() {
    if (occtLoaded) return occtLoaded;
    const urls = [
      '/static/occt/occt-import-js.js',
      // Try both jsDelivr and unpkg, with and without ?module (some CDNs dislike the query).
      'https://cdn.jsdelivr.net/npm/occt-import-js@1.1.0/dist/occt-import-js.js',
      'https://cdn.jsdelivr.net/npm/occt-import-js@1.1.0/dist/occt-import-js.js?module',
      'https://unpkg.com/occt-import-js@1.1.0/dist/occt-import-js.js',
      'https://unpkg.com/occt-import-js@1.1.0/dist/occt-import-js.js?module',
      'https://esm.sh/occt-import-js@1.1.0',
    ];
    for (const url of urls) {
      try {
        let mod = null;
        if (url.endsWith('.js')) {
          mod = await import(url).catch(() => null);
        }
        let base = url.startsWith('/') ? `${new URL(window.location.href).origin}${url.slice(0, url.lastIndexOf('/') + 1)}` : url.slice(0, url.lastIndexOf('/') + 1);
        let factory = mod?.default || mod?.occtimportjs || mod;
        if (factory && typeof factory === 'function') {
          occtLoaded = { factory, base };
          return occtLoaded;
        }
        // fallback to script tag/global
        const viaScript = await loadOcctViaScript(url);
        occtLoaded = viaScript;
        return occtLoaded;
      } catch (e) {
        console.warn("OCCT import failed for", url, e);
      }
    }
    throw new Error("Could not load OCCT importer (all sources)");
  }

  function clearModelCanvas(msg = "") {
    const canvasWrap = document.getElementById('model-canvas');
    if (!canvasWrap) return;
    canvasWrap.innerHTML = msg ? `<div class="muted">${msg}</div>` : "";
  }

  async function renderModel(id, fileHint = "") {
    const noteEl = document.getElementById('model-preview-note');
    if (noteEl) noteEl.textContent = "Loading 3D model...";
    clearModelCanvas();
    try {
      const resp = await fetch(`/api/jobs/candidates/${id}/download`);
      if (!resp.ok) throw new Error(`Download failed: ${resp.status}`);
      const blob = await resp.blob();
      const nameHint = (fileHint || resp.headers.get('content-disposition') || resp.url || '').toLowerCase();
      const arrayBuf = await blob.arrayBuffer();
      const { THREE, OrbitControls, OBJLoader, STLLoader, VRMLLoader } = await loadThree();

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f141b);
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
      camera.position.set(0, 0, 120);
      const light1 = new THREE.DirectionalLight(0xffffff, 1.1); light1.position.set(1, 1, 1); scene.add(light1);
      const light2 = new THREE.AmbientLight(0x404040, 1.2); scene.add(light2);

      let mesh = null;
      if (nameHint.includes('.stl')) {
        const loader = new STLLoader();
        const geo = loader.parse(arrayBuf);
        mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x3ecf8e, metalness: 0.1, roughness: 0.6 }));
      } else if (nameHint.includes('.obj')) {
        const loader = new OBJLoader();
        mesh = loader.parse(new TextDecoder().decode(new Uint8Array(arrayBuf)));
        mesh.traverse((child) => { if (child.isMesh) child.material = new THREE.MeshStandardMaterial({ color: 0x3ecf8e }); });
      } else if (nameHint.includes('.wrl') || nameHint.includes('.vrml')) {
        const loader = new VRMLLoader();
        mesh = loader.parse(new TextDecoder().decode(new Uint8Array(arrayBuf)));
      } else if (nameHint.includes('.step') || nameHint.includes('.stp')) {
        try {
          const { factory, base } = await loadOcct();
          const occt = await factory({
            locateFile: (file) => `${base}${file}`,
          });
          const uint8 = new Uint8Array(arrayBuf);
          const result = occt.ReadStepFile(uint8, undefined, { compress: true });
          if (result && result.meshes && result.meshes.length) {
            const group = new THREE.Group();
            result.meshes.forEach((m) => {
              const geometry = new THREE.BufferGeometry();
              if (m.attributes.position?.array) {
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(m.attributes.position.array), 3));
              }
              if (m.attributes.normal?.array) {
                geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(m.attributes.normal.array), 3));
              }
              if (m.index?.array) {
                geometry.setIndex(Array.from(m.index.array));
              }
              geometry.computeBoundingSphere();
              const mat = new THREE.MeshStandardMaterial({ color: 0x3ecf8e, metalness: 0.1, roughness: 0.6, side: THREE.DoubleSide });
              const child = new THREE.Mesh(geometry, mat);
              group.add(child);
            });
            mesh = group.children.length === 1 ? group.children[0] : group;
          } else {
            console.error("STEP render failed: no meshes");
          }
        } catch (e) {
          console.error("STEP render failed", e);
          const msg = `STEP parse failed: ${e?.message || e}. <a href="/api/jobs/candidates/${id}/download" target="_blank">Download model</a>`;
          clearModelCanvas(msg);
          if (noteEl) noteEl.innerHTML = msg;
          return;
        }
      }

      if (!mesh) {
        const msg = `Unsupported 3D format in browser viewer (try STL/OBJ/WRL/STEP). <a href="/api/jobs/candidates/${id}/download" target="_blank">Download model</a>`;
        clearModelCanvas(msg);
        if (noteEl) noteEl.innerHTML = msg;
        return;
      }

      scene.add(mesh);
      const box = new THREE.Box3().setFromObject(mesh);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      mesh.position.sub(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim * 1.6 || 80;
      camera.position.set(dist, dist, dist);
      camera.lookAt(0,0,0);

      const wrap = document.getElementById('model-canvas');
      if (!wrap) return;
      wrap.innerHTML = "";
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      const width = wrap.clientWidth || 480;
      const height = Math.min(480, Math.max(240, width * 0.6));
      renderer.setSize(width, height);
      wrap.appendChild(renderer.domElement);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.update();
      const animate = () => {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      };
      animate();
      currentModelUrl = URL.createObjectURL(blob);
      if (noteEl) noteEl.textContent = "Browser-rendered preview (rotate/zoom).";
    } catch (err) {
      const msg = `3D preview failed: ${err?.message || err}. <a href="/api/jobs/candidates/${id}/download" target="_blank">Download model</a>`;
      clearModelCanvas(msg);
      if (noteEl) noteEl.innerHTML = msg;
    }
  }

  function initOptionTiles() {
    document.querySelectorAll('.option-tile').forEach((btn) => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.type;
        applyTypeSelection(type, btn.dataset.candId || "", btn.dataset.compId || "");
        markSelected(type, btn);
        fetchPreview(type, btn);
        if (type === "model" && btn.dataset.candId) {
          renderModel(btn.dataset.candId, btn.dataset.file || "");
        }
      });
    });
    ["symbol", "footprint", "model"].forEach((type) => {
      const active = document.querySelector(`.option-tile[data-type="${type}"].selected`);
      if (active) {
        applyTypeSelection(type, active.dataset.candId || "", active.dataset.compId || "");
        fetchPreview(type, active);
        if (type === "model" && active.dataset.candId) renderModel(active.dataset.candId, active.dataset.file || "");
        return;
      }
      let chosen = null;
      document.querySelectorAll(`input[name^="${type}_"]`).forEach((hidden) => {
        if (!chosen && hidden.value) {
          chosen = document.querySelector(`.option-tile[data-type="${type}"][data-cand-id="${hidden.value}"]`);
        }
      });
      if (chosen) {
        markSelected(type, chosen);
        applyTypeSelection(type, chosen.dataset.candId || "", chosen.dataset.compId || "");
        fetchPreview(type, chosen);
        return;
      }
      const firstCandidate = document.querySelector(`.option-tile[data-type="${type}"]:not(.none)`);
      if (firstCandidate) {
        markSelected(type, firstCandidate);
        applyTypeSelection(type, firstCandidate.dataset.candId || "", firstCandidate.dataset.compId || "");
        fetchPreview(type, firstCandidate);
        if (type === "model" && firstCandidate.dataset.candId) renderModel(firstCandidate.dataset.candId, firstCandidate.dataset.file || "");
        return;
      }
      const noneBtn = document.querySelector(`.option-tile.none[data-type="${type}"]`);
      if (noneBtn) {
        markSelected(type, noneBtn);
        applyTypeSelection(type, "", "");
        fetchPreview(type, null);
      }
    });
  }
  initOptionTiles();

  // click-to-toggle fullscreen for preview window (symbols/footprints)
  document.addEventListener('click', (e) => {
    const target = e.target;
    if (!(target instanceof HTMLElement)) return;
    const win = target.closest('.preview-window');
    if (!win) return;
    if (win.classList.contains('modal-open')) {
      win.classList.remove('modal-open');
      const inner = win.querySelector('.preview-inner');
      if (inner instanceof HTMLElement) inner.style.transform = "translate(0px, 0px)";
    } else {
      win.classList.add('modal-open');
    }
  });

  // simple pan for modal-open preview window (drag)
  let isPanning = false;
  let startX = 0, startY = 0;
  let translateX = 0, translateY = 0;
  document.addEventListener('mousedown', (e) => {
    if (!(e.target instanceof HTMLElement)) return;
    const win = e.target.closest('.preview-window.modal-open');
    if (!win) return;
    isPanning = true;
    startX = e.clientX - translateX;
    startY = e.clientY - translateY;
    e.preventDefault();
  });
  document.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    translateX = e.clientX - startX;
    translateY = e.clientY - startY;
    document.querySelectorAll('.preview-window.modal-open .preview-inner').forEach((el) => {
      el.style.transform = `translate(${translateX}px, ${translateY}px)`;
    });
  });
  document.addEventListener('mouseup', () => {
    isPanning = false;
  });

  document.getElementById('import-btn')?.addEventListener('click', async () => {
    setActionStatus("Saving choices before import...");
    try {
      const saved = await saveSelections();
      if (!saved.ok) throw new Error(saved.message || "Failed to save choices");
      setActionStatus("Importing to KiCad...");
      const payload = {
        symbol_subdir: commonDestInput?.value?.trim() || null,
        footprint_subdir: commonDestInput?.value?.trim() || null,
        model_subdir: commonDestInput?.value?.trim() || null,
      };
      const resp = await fetch(`/api/jobs/${jobId}/import`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      const body = await resp.json();
      if (!resp.ok) throw new Error(body.detail || body.error || resp.statusText);
      setActionStatus("Import complete.");
      alert("Import complete.");
    } catch (err) {
      setActionStatus(`Import failed: ${err?.message || err}`);
    }
  });

  // attach extra file to job
  const attachBtn = document.getElementById('attach-file-btn');
  const attachInput = document.getElementById('attach-file-input');
  const attachStatus = document.getElementById('attach-status');
  attachBtn?.addEventListener('click', async () => {
    if (!attachInput?.files?.length) {
      if (attachStatus) attachStatus.textContent = "Choose a file first.";
      return;
    }
    const file = attachInput.files[0];
    const fd = new FormData();
    fd.append("file", file);
    if (attachStatus) attachStatus.textContent = "Uploading and scanning...";
    try {
      const resp = await fetch(`/api/jobs/${jobId}/attach-file`, { method: "POST", body: fd });
      const body = await resp.json();
      if (!resp.ok) throw new Error(body.detail || resp.statusText);
      if (attachStatus) attachStatus.textContent = "Attached. Reloading...";
      window.location.reload();
    } catch (err) {
      if (attachStatus) attachStatus.textContent = `Attach failed: ${err?.message || err}`;
    }
  });
</script>
{% endblock %}
